# Bindless Images

:source-highlighter: coderay
:coderay-linenums-mode: table
:dpcpp: pass:[DPC++]

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en

:blank: pass:[ +]
// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}


- [Bindless Images](#bindless-images)
  - [Notice](#notice)
  - [Dependencies](#dependencies)
  - [Status](#status)
  - [Terminology](#terminology)
  - [Overview](#overview)
    - [Background](#background)
    - [Specification](#specification)
  - [Definitions](#definitions)
    - [Interfaces](#interfaces)
    - [Enums](#enums)
  - [Programming example](#programming-example)
    - [Non-USM](#non-usm)
    - [USM](#usm)
  - [Known Issues and Limitations](#known-issues-and-limitations)
  - [Revision History](#revision-history)

== Notice

[%hardbreaks]
Copyright (C) Codeplay. All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc. used by
permission by Khronos.


== Dependencies

This extension is written against the Level Zero v1.5.8 specification.

== Status

This is an experimental extension specification, intended to provide early
access to features and gather community feedback.

== Terminology

For the purposes of this document, a bindless image is one which provides
stateless access to the underlying data via image reference handles. At the
application level, this allows the user to implement programs where the number
of images is not known at compile-time, and store all handles to images --
irrespective of varying formats and layouts -- in some container, e.g. a dynamic
array.

== Overview

In this document, we propose the following changes to the Level Zero API:

- The creation of images to be split into explicit allocation of image memory
  and the creation of image handles from the previously allocated memory
- Support for creation of images on linearly allocated memory backed by USM
- Addition of image memory copy functions that allow copying to and from image
  memory before an image handle's construction

Currently, in Level Zero, the `zeImageCreate` performs the image memory
allocation and image handle generation. Moreover, this function only allows for
the allocation of image memory in an implementation-specific layout. Delivering
the features proposed in this document will improve the functionality and
flexibility of the Level Zero API.


=== Background

The DPC++ bindless images extension has sought to provide the flexibility of
bindless images at the SYCL application level. Per the proposal, users would be
able to separate image memory allocation from the image handle creation.
Tools such as SYCLomatic would benefit from this flexibility when converting
CUDA to SYCL code. Level Zero's support for this extension would enable
converted code to run optimally on Intel hardware.

Additionally, per the DPC++ bindless images extension, users would be able to
create and sample images based on linearly allocated memory. A valuable use-case
is the creation of a bindless image on already existing USM memory, preventing
copies, and hardware sampling can be applied to that data.

This proposal aims to extend Level Zero to better align with the PI API used by
the SYCL runtime in DPC++.


=== Specification

To enable the separation of image memory allocation from image handle
generation, we propose two new allocation functions `zeMemAllocImageExp` and
`zeMemAllocPitchedExp`.

`zeMemAllocImageExp` will allocate non-USM image memory with an implementation
specific layout (such as tile swizzle patterns or lossless compression).

Whereas, `zeMemAllocPitchedExp` will allocate USM memory in a linear layout.
Memory allocated with this API should be freed using `zeMemFree`.

Alongside these allocation functions, we propose a singular additional freeing
function, `zeMemFreeImageExp`, to free memory allocated with
`zeMemAllocImageExp`.

We also propose a new struct `ze_device_image_bindless_exp_desc_t` that
describes device restrictions on image properties. It should be passed to
`ze_device_properties_t::pNext`. It contains the fields `imagePitchAlign`,
`maxImageLinearWidth`, `maxImageLinearHeight`, and `maxImageLinearPitch`.

== Definitions

```cpp
typedef uint64_t ze_image_mem_handle_exp_t;

///////////////////////////////////////////////////////////////////////////////
/// @brief Describes memory to be allocated on device intended for images with
///        a device specific memory layout
///
/// @details
///     - This structure is passed to:
///       + ::zeMemAllocImageExp
///       + ::ze_image_desc_t.pNext
///         - When this structure is passed to an image descriptor,
///           ::zeImageCreate must not allocate any additional device memory for
///           the created image, only return a handle.
///         - Additionally, when ::zeImageDestroy is called on an image created
///           from a ::ze_image_mem_alloc_exp_desc_t allocation,
///           ::zeImageDestroy must not free the memory associated with the
///           image handle.
///
typedef struct _ze_image_mem_alloc_exp_desc_t {
    ze_structure_type_t stype;      // [in]
    void *pNext;                    // [in,out][optional]
    size_t widthInBytes;            // [in]
    size_t height;                  // [in][optional]
    size_t depth;                   // [in][optional]
    uint32_t elementSizeByte;       // [in]
} ze_image_mem_alloc_exp_desc_t;

///////////////////////////////////////////////////////////////////////////////
/// @brief Describes linear USM to be allocated on device intended for images
///
/// @details
///     - This structure is passed to:
///       + ::zeMemAllocPitchedExp
///         - ::rowPitch and ::slicePitch are [out] parameters
///       + ::ze_image_desc_t.pNext
///         - ::rowPitch and ::slicePitch are [in] parameters
///         - When this structure is passed to an image descriptor,
///           ::zeImageCreate must not allocate any additional device memory for
///           the created image, only return a handle.
///         - Additionally, when ::zeImageDestroy is called on an image created
///           from a ::ze_image_mem_alloc_exp_desc_t allocation,
///           ::zeImageDestroy must not free the memory associated with the
///           image handle.
///
typedef struct _ze_image_usm_alloc_exp_desc_t {
    ze_structure_type_t stype;      // [in]
    void *pNext;                    // [in,out][optional]
    size_t widthInBytes;            // [in]
    size_t height;                  // [in][optional]
    size_t depth;                   // [in][optional]
    uint32_t elementSizeBytes;      // [in]
    size_t rowPitch;                // [in,out]
    size_t slicePitch;              // [in,out]
} ze_image_usm_alloc_exp_desc_t;

///////////////////////////////////////////////////////////////////////////////
/// @brief Describes device specific restrictions for image properties
///
/// @details
///     - This structure is passed to:
///       + ::ze_device_properties_t::pNext
///
typedef struct _ze_device_image_bindless_exp_desc_t {
    ze_structure_type_t stype;      // [in]
    void *pNext;                    // [in,out][optional]
    uint32_t imagePitchAlign;       // [out]
    size_t maxImageLinearWidth;     // [out]
    size_t maxImageLinearHeight;    // [out]
    size_t maxImageLinearPitch;     // [out]
} ze_device_image_bindless_exp_desc_t;
```

=== Interfaces

```cpp
///////////////////////////////////////////////////////////////////////////////
/// @brief Allocates on device memory intended for images
///
/// @details
///     - Allocates on device image memory in an implementation specific layout and encoding
///     - The memory allocated through this function should not be freed with ::zeMemFree,
///     - but rather with ::zeMemFreeImageExp
///     - Copy operations to or from this memory need to use ::zeCommandListAppendImage
///
/// @returns
///     - ::ZE_RESULT_SUCCESS
///     - ::ZE_RESULT_ERROR_INVALID_ARGUMENT
///         + invalid image_desc
///         + invalid mem_handle
///     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY
///         + out of memory
///     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE
///         + nullptr == hContext
ZE_APIEXPORT ze_result_t ZE_APICALL
zeMemAllocImageExp(
    ze_context_handle_t hContext,                       /// [in] handle of the context object
    const ze_image_mem_alloc_exp_desc_t *image_desc,    /// [in] memory allocation descriptor
    ze_image_mem_handle_exp_t *mem_handle               /// [out] pointer to device allocation handle
    );

///////////////////////////////////////////////////////////////////////////////
/// @brief Allocates pitched USM
///
/// @details
///     - Allocates USM in a linear layout
///     - Populates image_desc rowPitch and slicePitch variables
///     - The memory allocated through this function should be freed with ::zeMemFree
///
/// @returns
///     - ::ZE_RESULT_SUCCESS
///     - ::ZE_RESULT_ERROR_INVALID_ARGUMENT
///         + invalid image_desc
///         + invalid usm_ptr
///     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY
///         + out of memory
///     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE
///         + nullptr == hContext
ZE_APIEXPORT ze_result_t ZE_APICALL
zeMemAllocPitchedExp(
    ze_context_handle_t hContext,                       /// [in] handle of the context object
    const ze_image_usm_alloc_exp_desc_t *image_desc,    /// [in] usm allocation descriptor
    void **pptr                                         /// [out] pointer to device allocation
    );

///////////////////////////////////////////////////////////////////////////////
/// @brief Deallocates image memory
///
/// @details
///     - Deallocates image memory allocated through ::zeMemAllocImageExp
///
/// @returns
///     - ::ZE_RESULT_SUCCESS
///     - ::ZE_RESULT_ERROR_INVALID_ARGUMENT
///         + invalid mem_handle
///     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE
///         + nullptr == hContext
ZE_APIEXPORT ze_result_t ZE_APICALL
zeMemFreeImageExp(
    ze_context_handle_t hContext,                       /// [in] handle of the context object
    ze_image_mem_handle_exp_t mem_handle                /// [in] device allocation handle
    );

/// @brief Appends a command to copy image memory from the host to the device
///
/// @details
///     - This functions allows for the copying of data to image memory before
///       an image handle is created
///
/// @returns
///     - ::ZE_RESULT_SUCCESS
///     - ::ZE_RESULT_ERROR_UNINITIALIZED
///     - ::ZE_RESULT_ERROR_DEVICE_LOST
///     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY
///     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY
///     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE
///         + nullptr == hCommandList
///         + nullptr == hDstImageMem
///     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER
///         + nullptr == srcptr
///     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT
///     - ::ZE_RESULT_ERROR_INVALID_SIZE
///         + (nullptr == phWaitEvents) && (0 < numWaitEvents)
ZE_APIEXPORT ze_result_t ZE_APICALL
zeCommandListAppendImageMemoryCopyFromHostExp(
    ze_command_list_handle_t hCommandList,              /// [in] handle of command list
    ze_image_mem_handle_exp_t hDstImageMem,             /// [in] handle of destination image memory to copy to
    const void *srcptr,                                 /// [in] pointer to source memory to copy from
    const ze_image_region_t *pDstRegion,                /// [in][optional] destination region descriptor
    ze_event_handle_t hSignalEvent,                     /// [in][optional] handle of the event to signal on completion
    uint32_t numWaitEvents,                             /// [in][optional] number of events to wait on before launching
    ze_event_handle_t *phWaitEvents                     /// [in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching
)

/// @brief Appends a command to copy image memory from the device to the host
///
/// @details
///     - This functions allows for the copying of data from image memory before
///       an image handle is created
///
/// @returns
///     - ::ZE_RESULT_SUCCESS
///     - ::ZE_RESULT_ERROR_UNINITIALIZED
///     - ::ZE_RESULT_ERROR_DEVICE_LOST
///     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY
///     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY
///     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE
///         + nullptr == hCommandList
///         + nullptr == hDstImageMem
///     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER
///         + nullptr == srcptr
///     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT
///     - ::ZE_RESULT_ERROR_INVALID_SIZE
///         + (nullptr == phWaitEvents) && (0 < numWaitEvents)
ZE_APIEXPORT ze_result_t ZE_APICALL
zeCommandListAppendImageMemoryCopyToHostExp(
    ze_command_list_handle_t hCommandList,              /// [in] handle of command list
    void *dstptr,                                       /// [in] pointer to destination memory to copy to
    const ze_image_mem_handle_t hSrcImageMem,           /// [in] handle of source image memory to copy from
    const ze_image_region_t *pSrcRegion,                /// [in][optional] source region descriptor
    ze_event_handle_t hSignalEvent,                     /// [in][optional] handle of the event to signal on completion
    uint32_t numWaitEvents,                             /// [in][optional] number of events to wait on before launching
    ze_event_handle_t *phWaitEvents                     /// [in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching
)

/// @brief Appends a command to copy image USM memory from the host to the device
///
/// @details
///     - This functions allows for the copying of data to image memory before
///       an image handle is created
///
/// @returns
///     - ::ZE_RESULT_SUCCESS
///     - ::ZE_RESULT_ERROR_UNINITIALIZED
///     - ::ZE_RESULT_ERROR_DEVICE_LOST
///     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY
///     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY
///     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE
///         + nullptr == hCommandList
///         + nullptr == hDstImageMem
///     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER
///         + nullptr == srcptr
///     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT
///     - ::ZE_RESULT_ERROR_INVALID_SIZE
///         + (nullptr == phWaitEvents) && (0 < numWaitEvents)
ZE_APIEXPORT ze_result_t ZE_APICALL
zeCommandListAppendImageUSMCopyFromHostExp(
    ze_command_list_handle_t hCommandList,              /// [in] handle of command list
    void *dstptr,                                       /// [in] pointer to destination image USM to copy to
    const void *srcptr,                                 /// [in] pointer to source memory to copy from
    const ze_image_region_t *pDstRegion,                /// [in][optional] destination region descriptor
    ze_event_handle_t hSignalEvent,                     /// [in][optional] handle of the event to signal on completion
    uint32_t numWaitEvents,                             /// [in][optional] number of events to wait on before launching
    ze_event_handle_t *phWaitEvents                     /// [in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching
)

/// @brief Appends a command to copy image USM memory from the device to the host
///
/// @details
///     - This functions allows for the copying of data from image USM memory
///       before an image handle is created
///
/// @returns
///     - ::ZE_RESULT_SUCCESS
///     - ::ZE_RESULT_ERROR_UNINITIALIZED
///     - ::ZE_RESULT_ERROR_DEVICE_LOST
///     - ::ZE_RESULT_ERROR_OUT_OF_HOST_MEMORY
///     - ::ZE_RESULT_ERROR_OUT_OF_DEVICE_MEMORY
///     - ::ZE_RESULT_ERROR_INVALID_NULL_HANDLE
///         + nullptr == hCommandList
///         + nullptr == hDstImageMem
///     - ::ZE_RESULT_ERROR_INVALID_NULL_POINTER
///         + nullptr == srcptr
///     - ::ZE_RESULT_ERROR_INVALID_SYNCHRONIZATION_OBJECT
///     - ::ZE_RESULT_ERROR_INVALID_SIZE
///         + (nullptr == phWaitEvents) && (0 < numWaitEvents)
ZE_APIEXPORT ze_result_t ZE_APICALL
zeCommandListAppendImageUSMCopyToHostExp(
    ze_command_list_handle_t hCommandList,              /// [in] handle of command list
    void *dstptr,                                       /// [in] pointer to destination memory to copy to
    const void *srcptr,                                 /// [in] pointer to source image USM to copy from
    const ze_image_region_t *pSrcRegion,                /// [in][optional] source region descriptor
    ze_event_handle_t hSignalEvent,                     /// [in][optional] handle of the event to signal on completion
    uint32_t numWaitEvents,                             /// [in][optional] number of events to wait on before launching
    ze_event_handle_t *phWaitEvents                     /// [in][optional][range(0, numWaitEvents)] handle of the events to wait on before launching
)
```


=== Enums
We propose the following additional structure type enums for the structures
defined above.

```cpp
enum ze_structure_type_t {
    ZE_STRUCTURE_TYPE_IMAGE_MEM_ALLOC_DESC, /* ze_image_mem_alloc_desc_t */
    ZE_STRUCTURE_TYPE_IMAGE_USM_ALLOC_DESC /* ze_image_usm_alloc_desc_t */
};
```

== Programming example

=== Non-USM

```cpp
// Assumed constructed device and context
ze_device_handle_t hDevice;
ze_context_handle_t hContext;

// Assumed allocated command list
ze_command_list_handle_t hCommandList;

// Assumed image data on host
std::vector<float> imageDataHost;

// 2D image dimensions
size_t imageWidth = 1024;
size_t imageHeight = 1024;

// Create a non-USM image memory allocation descriptor
ze_image_mem_alloc_exp_desc_t imageMemAllocDesc = {
  ZE_STRUCTURE_TYPE_IMAGE_MEM_ALLOC_DESC,       /* stype */
  nullptr,                                      /* pNext */
  imageWidth * sizeof(float),                   /* widthInBytes */
  imageHeight,                                  /* height */
  0,                                            /* depth */
  sizeof(float)                                 /* elementSizeBytes */
};

// Allocate image memory and return the handle to that memory
ze_image_mem_handle_exp_t hImageMem;
zeMemAllocImageExp(hContext, &imageMemAllocDesc, &hImageMem);

// Copy from host to device
// Our extension allows us to copy to image memory before the image handle
// itself is created
// If the `hImageMem` has a device specific layout, this copy will need
// to transform the linear host memory to device specific layout
zeCommandListAppendImageMemoryCopyFromHostExp(hCommandList,
                                              hImageMem,
                                              imageDataHost.data(),
                                              nullptr /* pDstRegion */,
                                              nullptr /* hSignalEvent */,
                                              0 /* numWaitEvents */,
                                              nullptr /* phWaitEvents */);


// Single-precision float image format with one channel
ze_image_format_t imageFormat = {
  ZE_IMAGE_FORMAT_LAYOUT_32,      /* layout */
  ZE_IMAGE_FORMAT_TYPE_FLOAT,     /* type */
  ZE_IMAGE_FORMAT_SWIZZLE_R,      /* swizzle x -> R */
  ZE_IMAGE_FORMAT_SWIZZLE_X,      /* swizzle y -> don't care */
  ZE_IMAGE_FORMAT_SWIZZLE_X,      /* swizzle z -> don't care */
  ZE_IMAGE_FORMAT_SWIZZLE_X       /* swizzle w -> don't care */
}

// 2D image descriptor using previously allocated memory (`imageMemAllocDesc`)
ze_image_desc_t imageDesc = {
    ZE_STRUCTURE_TYPE_IMAGE_DESC, /* stype */
    &imageMemAllocDesc,           /* pNext */
    0,                            /* flags, set to read only */
    ZE_IMAGE_TYPE_2D,             /* type */
    imageFormat,                  /* format */
    1024,                         /* width */
    1024,                         /* height */
    0,                            /* depth */
    0,                            /* arrayLevels */
    0                             /* miplevels */
};


// Create image from memory allocated above
ze_image_handle_t hImage;
zeImageCreate(hContext, hDevice, &imageDesc, &hImage);

// Now we can operate on the image, passing `imageHandle` as an argument
// to a kernel

// Copy from device to host
// If the `hImageMem` has a device specific layout, this copy will need
// to transform the device specific memory layout to a linear host memory layout
zeCommandListAppendImageMemoryCopyToHostExp(hCommandList,
                                            imageDataHost.data(),
                                            hImageMem,
                                            nullptr /* pDstRegion */,
                                            nullptr /* hSignalEvent */,
                                            0 /* numWaitEvents */,
                                            nullptr /* phWaitEvents */);

// Once all operations on the image are complete we need to free the memory and
// destroy the handle

// Free image memory
zeMemFreeImageExp(hContext, hImage);

// Destroy image handle
// NOTE: This must not free the memory the image was created with
zeImageDestroy(hImage);
```

=== USM

```cpp
// Assumed constructed device and context
ze_device_handle_t hDevice;
ze_context_handle_t hContext;

// Assumed allocated command list
ze_command_list_handle_t hCommandList;

// Assumed image data on host
std::vector<float> imageDataHost;

// 2D image dimensions
size_t imageWidth = 1024;
size_t imageHeight = 1024;

size_t imageRowPitch;
size_t imageSlicePitch;

// Create a non-USM image memory allocation descriptor
ze_image_usm_alloc_exp_desc_t imageUSMAllocDesc = {
  ZE_STRUCTURE_TYPE_IMAGE_USM_ALLOC_DESC,       /* stype */
  nullptr,                                      /* pNext */
  imageWidth * sizeof(float),                   /* widthInBytes */
  imageHeight,                                  /* height */
  0,                                            /* depth */
  sizeof(float),                                /* elementSizeBytes */
  &imageRowPitch,                               /* rowPitch */
  &imageSlicePitch                              /* slicePitch */
};

// Allocate USM image memory and return the pointer
void *imageMemDevice;
zeMemAllocPitchedExp(hContext, &imageUSMAllocDesc, &imageMemDevice);

// Copy from host to device
// Our extension allows us to copy to image memory before the image handle
// itself is created
zeCommandListAppendImageUSMCopyFromHostExp(hCommandList,
                                           imageMemDevice,
                                           imageDataHost.data(),
                                           nullptr /* pDstRegion */,
                                           nullptr /* hSignalEvent */,
                                           0 /* numWaitEvents */,
                                           nullptr /* phWaitEvents */);


// Single-precision float image format with one channel
ze_image_format_t imageFormat = {
  ZE_IMAGE_FORMAT_LAYOUT_32,      /* layout */
  ZE_IMAGE_FORMAT_TYPE_FLOAT,     /* type */
  ZE_IMAGE_FORMAT_SWIZZLE_R,      /* swizzle x -> R */
  ZE_IMAGE_FORMAT_SWIZZLE_X,      /* swizzle y -> don't care */
  ZE_IMAGE_FORMAT_SWIZZLE_X,      /* swizzle z -> don't care */
  ZE_IMAGE_FORMAT_SWIZZLE_X       /* swizzle w -> don't care */
}

// 2D image descriptor using previously allocated memory (`imageUSMAllocDesc`)
ze_image_desc_t imageDesc = {
    ZE_STRUCTURE_TYPE_IMAGE_DESC, /* stype */
    &imageUSMAllocDesc,           /* pNext */
    0,                            /* flags, set to read only */
    ZE_IMAGE_TYPE_2D,             /* type */
    imageFormat,                  /* format */
    1024,                         /* width */
    1024,                         /* height */
    0,                            /* depth */
    0,                            /* arrayLevels */
    0                             /* miplevels */
};


// Create image from memory allocated above
ze_image_handle_t hImage;
zeImageCreate(hContext, hDevice, &imageDesc, &hImage);

// Now we can operate on the image, passing `imageHandle` as an argument
// to a kernel

// Copy from device to host
zeCommandListAppendImageUSMCopyToHostExp(hCommandList,
                                         imageDataHost.data(),
                                         imageMemDevice,
                                         nullptr /* pDstRegion */,
                                         nullptr /* hSignalEvent */,
                                         0 /* numWaitEvents */,
                                         nullptr /* phWaitEvents */);

// Once all operations on the image are complete we need to free the memory and
// destroy the handle

// Free image memory
zeMemFree(hContext, imageMemDevice);

// Destroy image handle
// NOTE: This must not free the memory the image was created with
zeImageDestroy(hImage);
```

== Known Issues and Limitations

How will this support mipmaps in the future?

== Revision History

[frame="none",options="header"]
|======================
|Rev |Date |Changes
|1 |2023-02-23 | Initial draft
|2 |2023-04-11 | - Re-designed the API
                 - Re-worked "overview" and "background" sections
                 - Added "specification overview" section
                 - Added "definitions", "interfaces", and "enums" sections
                 - Added programming example section
                 - Added table of contents
|======================
