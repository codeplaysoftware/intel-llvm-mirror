= SYCL_EXT_ONEAPI_NEW_GROUPS
:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en

:blank: pass:[ +]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}

== Introduction
IMPORTANT: This specification is a draft.

NOTE: Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc. used by permission by Khronos.


To fully exploit the available resources, modern hardware architectures allow for further sub-divisions of sub-groups. 
Managing synchronization in divergent control-flow can become awkward, especially when programming library code.
This proposal introduces new classes to represent sub-divisions of SYCL sub-groups, allowing for easier synchronization and cooperation.
These new classes can be used as function arguments to convey exactly what group the function is expecting, simplifying the interface and greatly reducing the amount of delicate wording needed in function documentation.
The group functions and algorithms will also be updated to simplify use of these groups.

== Important Terms

Control flow is defined in the SYCL specification link:https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#glossary[glossary].
Divergent work-items are work-items with control flow that has diverged with respect to the others.

Independent forward progess refers to the ability of individual work-items to execute a sequence of instructions regardless of when other work-items are executing or which instructions other work-items are executing. 
Portable SYCL programs must assume independent forward progress can be supported by the hardware since this ability is implementation defined as specified in link:https://www.khronos.org/registry/SYCL/specs/sycl-2020/html/sycl-2020.html#_forward_progress[section 3.8.3.4] of the specification.

Work-items executing in lock-step are in converged control flow and executing the same instructions at the same time.

== Changes to `sub_group`

To create the new groups, the `sub_group` class would be extended to add new member functions.

[source, c++]
----
namespace sycl::ext::oneapi {
class sub_group{
...
// return a group consisting of the work-items in the sub-group that call this function in lock-step.
// This can be called in divergent control flow since no synchronization is needed.
opportunistic_group ext_oneapi_get_opportunistic_group() const;

// return a group consisting of the work-items in the sub-group that gave the value 'true' for the `predicate` argument.
// This will cause synchronization of source_group.
template <typename non_uniform_sub_group>
ballot_group ext_oneapi_get_ballot_group(non_uniform_sub_group source_group, bool predicate) const;

// return a group consisting of the work-items in the sub-group that are in the same cluster as the calling work-item.
// A cluster has certain properties, defined in the cluster_group class section.
// This can be called in divergent control flow since no synchronization is needed.
template <size_t cluster_size> 
cluster_group ext_oneapi_get_cluster_group() const;
...
};
}
----


== The `opportunistic_group` Class

Possible alternative names - `diverged_group`, `reactive_group`, `transient_group`.

Divergent control flow and independent forward progress can lead to not all work-items of a sub-group executing in lock-step.
In some cases it may be helpful to capture this group and use it for some opportunistic optimization, the creation of a `opportunistic_group` from a sub-group will capture this group.
One example could be to aggregate an atomic operation across the work-items in a sub-group ready to perform the atomic, thus reducing the contention on the atomic.
The creation of an `opportunistic_group` does not require any synchronization because the work-items are implicitly executing in lock-step.

The following example shows an atomic pointer being incremented.
It is expected that all the work-items in the sub_group will increment the atomic value, but we opportunistically capture the groups of threads as they arrive to this point in the control flow.

[source, c++]
----
template <sycl::memory_order order, sycl::memory_scope scope, sycl::access::address_space addr_space>
int atomic_aggregate_inc(sycl::sub_group sub_group, sycl::atomic_ref<int, order, scope, addr_space> ptr) {
    sycl::ext::oneapi::opportunistic_group active_group = sub_group.ext_oneapi_get_opportunistic_group();
    int count = active_group.get_local_linear_range();
    int old_value;
    if (active_group.leader()) {
        old_value = ptr.fetch_add(count);
    }
    // return the value the individual work-item might have received if it had worked alone.
    auto index_in_group = active_group.get_local_linear_id();
    return sycl::select_from_group(active_group, old_value, 0) + index_in_group; 
}
----

The user should *not* assume the creation of an `opportunisic_group` will capture all converged work-items.
Due to independent forward progress, there is no guarentee that work-items will remain in lock-step, even when there is no divergence.
To group work-items following a common control flow, use a `ballot_group`.


The `opportunistic_group` class would have the following interface:

[source, c++]
----
namespace sycl::ext::oneapi {
class opportunistic_group {
public:
    using id_type = id<1>;
    using range_type = range<1>;
    using linear_id_type = uint32_t;
    static constexpr int dimensions = 1;
    static constexpr sycl::memory_scope fence_scope =
        sycl::memory_scope::non_uniform_sub_group;
    
    // get the id within the opportunistic-group
    id_type get_local_id() const;
    // get the id within the opportunistic-group
    linear_id_type get_local_linear_id() const;
    // get the size of the opportunistic-group
    range_type get_local_range() const;
    // get the size of the opportunistic-group
    linear_id_type get_local_linear_range() const;
    // true for only one work-item in the group
    bool leader() const;
};
}
----

NOTE: `opportunistic_group` does not have a group id or group range because the idea of other divisions of the sub_group doesn't have much meaning.

== The `ballot_group` Class

Currently in SYCL the control flow of a group must be converged to synchronize the work-items in the group.
This makes it impossible to have a synchronization point when work-items follow divergent control flow (e.g. when using if statements) without reconverging the group.
A ballot-group will allow the programmer to group the work-items in a sub-group or non-uniform sub-group that match a runtime predicate, allowing for the synchronization of a subset of work-items in a sub-group or non-uniform sub-group which all following the same control flow.
The sub-group or non-uniform sub-group that is divided will be referred to as the source group.
The creation of a ballot-group requires the synchronization of the source group since details of the other work-items in the ballot-group will be broadcast to participating work-items.
Work-items that supply a false value for the predicate must not use the `ballot_group`.

In the following example a sub-group is split up and one branch of the control flow performs a group barrier with a subset of the sub-group. This subset is then further subdivided.
[source, c++]
----
auto sub_group = it.get_sub_group();
auto will_branch = sub_group.get_local_linear_id() % 2 == 0;
// get group representing the subset of the sub-group that took the branch
sycl::ext::oneapi::ballot_group inner = sub_group.ext_oneapi_get_ballot_group(sub_group, will_branch);
if (will_branch)
{
  // synchronize across the work-items that took the branch
  sycl::group_barrier(inner);

  // reduce across subset of outer work-items that took the branch
  float ix = sycl::reduce(inner, x, plus<>());

  // once again diverge the groups without fear.
  auto will_branch_further = inner.get_local_linear_id() < 8;
  auto inner_inner = sub_group.ext_oneapi_get_ballot_group(inner, will_branch_further);
  if (will_branch_further) {
      // still synchronizing without deadlock
      sycl::group_barrier(inner_inner);
  }
}

// take a subset of an opportunistic group
auto matching_active_items = sub_group.ext_oneapi_get_ballot_group(
    sub_group.ext_oneapi_get_opportunistic_group(), some_predicate());
----

This will allow functions to cause divergent control flow without having to consider how to converge again to synchronize.

The `ballot_group` class would have the following interface:

[source, c++]
----
namespace sycl::ext::oneapi {
class ballot_group {
public:
    using id_type = id<1>;
    using range_type = range<1>;
    using linear_id_type = uint32_t;
    static constexpr int dimensions = 1;
    static constexpr sycl::memory_scope fence_scope =
        sycl::memory_scope::non_uniform_sub_group;
    
    // get the id within the ballot-group
    id_type get_local_id() const;
    linear_id_type get_local_linear_id() const;

    // get the size of the ballot-group
    range_type get_local_range() const;
    linear_id_type get_local_linear_range() const;

    // true for only one work-item in the group
    bool leader() const;
};
}
----

NOTE: `ballot_group` does not have a group id or group range because its obvious this is one of two groups and an ordering of the groups doesn't have meaning.

== The `cluster_group` Class

With the introduction on independent forward progress in sub_groups comes the possibility to partition sub-groups into smaller groups that work independently.
This could be acheived with a `ballot_group`, but when the group size is known at compile-time, the size can be used for optimizations such as loop unrolling.

[source, c++]
----
// sum the buffer in groups of 8
constexpr std::size_t cluster_size = 8;
auto sub_group = it.get_sub_group();
auto cluster = sub_group.ext_oneapi_get_cluster_group<cluster_size>();
// compiler knows that exactly 3 shuffles are needed to sum the values
auto result = sycl::reduce(cluster, buf[it.get_local_linear_id()], sycl::plus<>());
if (cluster.leader()){
    buf[it.get_local_linear_id()/cluster_size] = result;
}
----

To allow for predictable behaviour and optimizations, clusters/cluster-groups will have a number of properties:

* The work items in a cluster will be contiguous in the sub_group.
* Clusters sizes must be powers of two, and less than or equal to `get_max_local_range`.
* For a given `cluster_size`, a work-item will only be in a single cluster and always the same cluster.
* If `get_local_linear_range` is not evenly divisible by `cluster_size` then the behaviour is undefined.

These properties also mean that no synchronization is needed to created a cluster-group, a work-item can independently calculate the cluster it belongs to, meaning that cluster-groups can be created in divergent control-flow and without any synchronization.

NOTE: To create a smaller cluster-group, just call `sub_group::ext_oneapi_get_cluster_group` again. If you want to sub-divide a cluster-group in a way other than is provided by cluster-group, then `sub_group::ext_oneapi_get_ballot_group` can be used.

Another use of `cluster_group` would be to provide an interface with a compile-time known size of cluster-group as an argument.

[source, c++]
----
void func_that_needs_4_threads(sycl::ext::oneapi::cluster_group<4> group);
----


The `cluster_group` class would have the following interface:

[source, c++]
----

namespace sycl::ext::oneapi {
template <std::size_t cluster_size>
class cluster_group {
public:
    using id_type = id<1>;
    using range_type = range<1>;
    using linear_id_type = uint32_t;
    static constexpr int dimensions = 1;
    static constexpr sycl::memory_scope fence_scope =
        sycl::memory_scope::non_uniform_sub_group;
    
    // get the id within the cluster-group
    id_type get_local_id() const;
    linear_id_type get_local_linear_id() const;

    // get the size of the cluster-group
    range_type get_local_range() const;
    linear_id_type get_local_linear_range() const;

    // get the id of the cluster-group in the sub-group
    id_type get_group_id() const;
    linear_id_type get_group_linear_id() const;

    // get the number of cluster-groups in the sub-group
    range_type get_group_range() const;
    linear_id_type get_group_linear_range() const;

    // true for only one work-item in the group
    bool leader() const;
};
}
----

== Changes to `memory_scope`

A new memory scope should be added.

[source, c++]
----
namespace sycl {

enum class memory_scope : /* unspecified */ {
  work_item, sub_group, work_group, device, system, ext_oneapi_non_uniform_sub_group
};
inline constexpr auto memory_scope_work_item = memory_scope::work_item;
inline constexpr auto memory_scope_sub_group = memory_scope::sub_group;
inline constexpr auto memory_scope_work_group = memory_scope::work_group;
inline constexpr auto memory_scope_device = memory_scope::device;
inline constexpr auto memory_scope_system = memory_scope::system;
namespace ext::oneapi {
    inline constexpr auto memory_scope_non_uniform_sub_group = sycl::memory_scope::ext_oneapi_non_uniform_sub_group;
}

} // namespace sycl

----

== Group Functions

The `sycl::is_group` function should be update to reflect that `opportunistic_group`, `ballot_group`, and `cluster_group` are now also groups.
This will also mean updating some template functions that used is_group to disable template specializations.

`sycl::group_barrier` and `sycl::broadcast` should be updated to work with all the group types.

== Group Algorithms

A subset of the group algorithms have been chosen to reduce the scope of the extension:

* `sycl::joint_reduce` and `sycl::reduce_over_group` should be included since they covers many general uses.
* `sycl::select_from_group` should be included to make the aggregate atomics example possible.

Other algorithms could be added later.

== Async Group Copy and Wait

This proposal would also build on the link:https://github.com/intel/llvm/pull/4950[prospective proposal] to generalize `sycl::group::async_work_group_copy` and `sycl::group::wait_for` to work with sub-groups.

Both `sycl::ext::oneapi::experimental::async_group_copy` and `sycl::ext::oneapi::experimental::wait_for` would work with `opportunistic_group`, `ballot_group`, and `cluster_group` with the same semantics.


== Issues
. What happens when work-items in different control-flow call ext_oneapi_get_opportunistic_group?
. The conditions for calling the group functions and algorithms need to be decided on. It makes sense that reaching a group algorithm from a different control-flow should be undefined behaviour, but is that at all enforcable or detectable? Should it be possible to call group algorithms and group functions with different group at the same time? Multiple ballot-groups with non-overlapping members trying to do a reduce at the same time seems like a common use case, but will hardware support it?
. do we want a memory scope for each new class or just non_uniform_sub_group?
. Potentially `ext_oneapi_get_opportunistic_group`, `ext_oneapi_get_ballot_group`, and `ext_oneapi_get_cluster_group` could be free functions. This would avoid the slightly weird pattern where the sub-group uses itself as the first argument to `sub_group::ext_oneapi_get_ballot_group` i.e. `subgroup.ext_oneapi_get_ballot_group(subgroup, predicate);`. On the other hand, this would be inconsistent with the method of querying a sub-group from a work-group.
. Could work-items that provide `ext_oneapi_get_ballot_group` with false use the ballot group to query the size of the group?

== Notes
. It is intentionally not possible to query the work-items location in the sub-group from `opportunistic_group`, `ballot_group`, or `cluster_group`. Since it is not possible to query a work-items id in the work-group from the sub-group, it follows that it is not possible to query a work-items id in the sub-group from the sub-sub-group.
. If the main purpose of `group_ballot` from the link:https://github.com/intel/llvm/blob/sycl/sycl/doc/extensions/SubGroupMask/SubGroupMask.asciidoc[sub group mask proposal] is to represent subsets of sub-groups, then this work would make that redundant.

== Sub-dividing groups
It would be nice to be able to sub-divide these non-uniform sub-groups but it is likely only reasonable to be able to create ballot-groups from the other groups.

=== Ballot-Group
To create a ballot-group, members of a sub-groups, ballot-groups, opportunistic-groups, and cluster-groups could all broadcast the result of some predicate function.

=== Cluster-Group
The creation of a cluster-group only depends on the size of a sub-group and the location of a work-item within that sub-group, meaning any work-item can calculate the cluster-group it belongs in with no synchronization. It is indirect to use another group in the creation of a cluster-group when the implementation will be querying the containing sub-group and ignoring other information.

=== Opportunistic-Group
To create an opportunistic-group from another group, would likely involve finding the intersection of a new opportunistic-group and another group. Without hardware support, this would require synchronization between work-items and is effectively equal to creating a ballot-group, so a ballot-group should be used instead.
 
